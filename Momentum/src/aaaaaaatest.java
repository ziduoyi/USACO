import java.util.*;
public class aaaaaaatest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		aaaaaaatest ex=new aaaaaaatest();	
		System.out.println(ex.maxResult(new int[] {-8751,2479,-8909,5915,-9938,8538,5751,7284,-7379,-4367,6505,3554,-5997,-6086,-1614,-5979,6749,-2391,-3374,7646,3647,6446,-9155,-9569,9417,-608,7598,-4284,-5408,-8498,5449,894,-9330,3331,-8687,6031,6997,-9019,-7583,-6270,-7836,-3382,-9933,-5603,-3330,-3060,4249,5854,6799,2032,-5227,-6835,-514,-9969,2914,3560,-4754,3935,6,-6873,-6121,1756,-1702,-4168,-3049,8798,-6519,-3734,7904,-2029,-9535,-497,-1884,0,-2868,7068,320,7657,-2448,-3848,-5441,271,-4446,-1840,3395,-5776,7654,4696,-2050,-1714,-9327,1140,7027,-8260,635,-995,-3854,1275,7125,-2973,-4000,-5763,3875,-9884,8083,6025,-5966,-3248,8097,6167,4531,9197,-8117,3401,-3411,-6569,-4305,945,709,1728,-8471,316,-2213,9566,9603,7678,8373,-9312,-9306,4408,9822,-2726,6743,-5390,-5726,-4101,3615,-9454,1727,-5379,-7579,-7083,-8708,3613,5521,-3671,-7573,4374,4497,636,-9884,-5314,-45,5832,7020,-899,-1671,3271,-1314,-7484,6319,-7311,-3887,6879,7228,-4873,763,-9875,9316,-2991,-6360,-2351,6273,-2294,434,-6143,363,5535,6641,2221,-9427,-2443,-9143,172,7606,3193,-1466,7586,4580,-3962,3193,5961,-7064,-3555,9468,833,-4803,-8904,-4420,7071,535,8434,946,-8901,2702,-1115,-8466,8226,9452,3723,-7267,7925,3607,-7495,8233,1339,5613,-3891,-2668,3444,-329,1989,-792,-8883,-3188,-23,5538,-5422,6014,-5527,-4000,-6444,-165,-1102,5296,-2594,-7302,5851,-594,4749,6262,7106,-670,-8386,7080,4692,5384,8080,8406,8244,-6144,4063,-7125,4303,-7760,8335,9739,3881,-2077,-9156,-9801,-2765,7807,-8890,7550,3027,-3889,-9448,2116,-8265,-9078,2413,-7092,-9806,7038,3219,3659,-1132,9562,4550,7413,-3573,-2096,-2366,7884,-7314,4269,3432,2279,-8153,-2801,-6849,5963,-3272,3901,-1204,-5353,2078,-9675,8712,-1259,-1291,-7596,2671,7828,-1451,-7926,8603,-4858,2600,7982,-5178,-3877,-1399,4303,9696,6289,6138,-6884,1533,6992,-6123,-5468,5735,5003,5114,7969,8887,4682,-9921,9199,9000,2609,4880,-237,9093,9268,8609,-4320,5009,-9188,-1013,1057,-864,1263,-8229,6653,3873,3652,6519,9403,-2003,-8130,-4121,-6671,7602,7237,3692,-3264,5818,-5892,-9488,-1774,-4083,-9104,6320,5728,5473,5616,7864,4349,7869,-2569,-6529,-8611,-5712,-8372,-1882,8429,7119,8314,-7453,-5330,-1949,5510,9069,6760,-3449,993,8079,8856,663,7556,-5227,-9243,-9425,1912,4663,2976,-4100,-1888,2055,-6330,-2035,8527,-2760,2816,5294,6866,560,-8042,2340,-8531,-8666,-8095,-4926,5016,-905,-387,4079,-1954,-941,9669,4548,2883,4976,7238,-8685,-2256,1906,6226,-2233,-925,-2392,-5148,-9405,-8689,-6705,9853,-1119,9765,3518,5757,-1933,7398,-724,-5328,4931,-3920,3458,628,8111,-4941,9529,-9965,-109,-6392,-4357}, 104));
		//ex.distanceLimitedPathsExist(5, new int[][] {{0,1,10},{1,2,5},{2,3,9},{3,4,13}}, new int[][] {{0,4,14},{1,4,13}});
		//System.out.println(ex.maxHeight(new int[][] {{50,45,20},{95,37,53},{45,23,12}}));
		//ex.combinationSum(new int[] {2,3,6,7}, 7);
		//System.out.println(ex.splitArray(new int[] {7,2,5,10,8}, 2));
		//System.out.println(ex.minimumDistance("HAPPY"));
		//System.out.println(ex.findMedianSortedArrays(new int[] {1, 2}, new int[] {3,4}));
		//System.out.println(ex.rectangleFilling(new int[][] {{2,3},{9,8},{4,5},{7,7},{10,2}, {7,6}}));
		//System.out.println(ex.minDistance("ab","bc"));
		//System.out.println(ex.maxScoreWords(new String[] {"dog","cat","dad","good"}, new char[] {'a','a','c','d','d','d','g','o','o'}, new int[] {1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0}));
		//System.out.println(ex.closedIsland(new int[][] {{1,1,1,1,1,1,1,0},{1,0,0,0,0,1,1,0},{1,0,1,0,1,1,1,0},{1,0,0,0,0,1,0,1},{1,1,1,1,1,1,1,0}}));
		///System.out.println(ex.largest1BorderedSquare(new int[][] {{1,1,1},{1,0,1},{1,1,1}}));
	//	System.out.println(ex.alienDictionary(new String[] {
		                                                // .args  "z",
		                                                 //  "x",
		                                                 //  "z"
	//}));
		//ex.useless(10,10);
		//System.out.println(ex.lastStoneWeightII(new int[] {2,7,4,1,8,1}));
		//System.out.println(ex.minStickers(new String[]{"city","would","feel","effect","cell","paint"}		,"putcat"));
		//System.out.println(ex.longestDupSubstring("okmzpmxzwjbfssktjtebhhxfphcxefhonkncnrumgduoaeltjvwqwydpdsrbxsgmcdxrthilniqxkqzuuqzqhlccmqcmccfqddncchadnthtxjruvwsmazlzhijygmtabbzelslebyrfpyyvcwnaiqkkzlyillxmkfggyfwgzhhvyzfvnltjfxskdarvugagmnrzomkhldgqtqnghsddgrjmuhpgkfcjkkkaywkzsikptkrvbnvuyamegwempuwfpaypmuhhpuqrufsgpiojhblbihbrpwxdxzolgqmzoyeblpvvrnbnsdnonhpmbrqissifpdavvscezqzclvukfgmrmbmmwvzfpxcgecyxneipexrzqgfwzdqeeqrugeiupukpveufmnceetilfsqjprcygitjefwgcvqlsxrasvxkifeasofcdvhvrpmxvjevupqtgqfgkqjmhtkyfsjkrdczmnettzdxcqexenpxbsharuapjmdvmfygeytyqfcqigrovhzbxqxidjzxfbrlpjxibtbndgubwgihdzwoywqxegvxvdgaoarlauurxpwmxqjkidwmfuuhcqtljsvruinflvkyiiuwiiveplnxlviszwkjrvyxijqrulchzkerbdyrdhecyhscuojbecgokythwwdulgnfwvdptzdvgamoublzxdxsogqpunbtoixfnkgbdrgknvcydmphuaxqpsofmylyijpzhbqsxryqusjnqfikvoikwthrmdwrwqzrdmlugfglmlngjhpspvnfddqsvrajvielokmzpmxzwjbfssktjtebhhxfphcxefhonkncnrumgduoaeltjvwqwydpdsrbxsgmcdxrthilniqxkqzuuqzqhlccmqcmccfqddncchadnthtxjruvwsmazlzhijygmtabbzelslebyrfpyyvcwnaiqkkzlyillxmkfggyfwgzhhvyzfvnltjfxskdarvugagmnrzomkhldgqtqnghsddgrjmuhpgkfcjkkkaywkzsikptkrvbnvuyamegwempuwfpaypmuhhpuqrufsgpiojhblbihbrpwxdxzolgqmzoyeblpvvrnbnsdnonhpmbrqissifpdavvscezqzclvukfgmrmbmmwvzfpxcgecyxneipexrzqgfwzdqeeqrugeiupukpveufmnceetilfsqjprcygitjefwgcvqlsxrasvxkifeasofcdvhvrpmxvjevupqtgqfgkqjmhtkyfsjkrdczmnettzdxcqexenpxbsharuapjmdvmfygeytyqfcqigrovhzbxqxidjzxfbrlpjxibtbndgubwgihdzwoywqxegvxvdgaoarlauurxpwmxqjkidwmfuuhcqtljsvruinflvkyiiuwiiveplnxlviszwkjrvyxijqrulchzkerbdyrdhecyhscuojbecgokythwwdulgnfwvdptzdvgamoublzxdxsogqpunbtoixfnkgbdrgknvcydmphuaxqpsofmylyijpzhbqsxryqusjnqfikvoikwthrmdwrwqzrdmlugfglmlngjhpspvnfddqsvrajviel"));
		//System.out.println(ex.isMatch("abbabaaabbabbaababbabbbbbabbbabbbabaaaaababababbbabababaabbababaabbbbbbaaaabababbbaabbbbaabbbbababababbaabbaababaabbbababababbbbaaabbbbbabaaaabbababbbbaababaabbababbbbbababbbabaaaaaaaabbbbbaabaaababaaaabb","**aa*****ba*a*bb**aa*ab****a*aaaaaa***a*aaaa**bbabb*b*b**aaaaaaaaa*a********ba*bbb***a*ba*bb*bb**a*b*bb"));
		//System.out.println(ex.shortestCommonSupersequence("abac","cab"));
		//ex.checkInclusion("ab","eidbaooo");
		//System.out.println(Arrays.toString(ex. findRedundantConnection2(new int[][] {{1,4},{3,4},{1,3},{1,2},{4,5}})));
		
	}
    public int maxResult(int[] nums, int k) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, -1000000000);
        dp[0] = nums[0];
        TreeSet<Integer> set = new TreeSet<>();
        HashMap<Integer, Integer> map = new HashMap<>();
        set.add(nums[0]);
        map.put(nums[0],1);
        for(int i=1; i<nums.length; i++){
            if(i>k){
                if(map.get(dp[i-k-1])==1){
                    set.remove(dp[i-k-1]);
                    map.remove(dp[i-k-1]);
                }
                else
                    map.put(dp[i-k-1], map.get(dp[i-k-1])-1);
            }
            int num = set.pollLast();
            dp[i] = num + nums[i];
            set.add(num);
            if(set.contains(dp[i]))
                map.put(dp[i], map.get(dp[i])+1);
            else{
                set.add(dp[i]);
                map.put(dp[i], 1);
            }
        }
        return dp[nums.length-1];
                     
    }
	/*
    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {
        Arrays.sort(edgeList, new Comparator<int[]>() {
			@Override
			public int compare(int[] arg0, int[] arg1) {
				// TODO Auto-generated method stub
				return arg0[2] - arg1[2];
			}
        });
        int[][] quest = new int[queries.length][4];
        for(int i=0; i< queries.length; i++) {
        	for(int j=0; j<3; j++)
        		quest[i][j] = queries[i][j];
        	quest[i][3] = i;
        }
        Arrays.sort(quest, new Comparator<int[]>() {
			@Override
			public int compare(int[] arg0, int[] arg1) {
				// TODO Auto-generated method stub
				return arg0[2] - arg1[2];
			}
        });
        int[] roots = new int[n];
        for(int i=0; i<n; i++)
        	roots[i] = i;
        boolean[] ans = new boolean[queries.length];
        int j=0;
        for(int i=0; i<queries.length; i++) {
        	while(j<edgeList.length&&edgeList[j][2]<quest[i][2]) {
        		int r1 = find(roots, edgeList[j][0]);
        		int r2 = find(roots, edgeList[j][1]);
        		roots[r1] = r2;
        		j++;
        	}
        	if(find(roots,quest[i][0])==find(roots, quest[i][1]))
        		ans[quest[i][3]] = true;
        }
        return ans;
    }
    static int find(int[] roots, int node) {
    	int old = node;
    	while(node!=roots[node]) 
    		node = roots[node];
    	while(old!=node) {
    		old = roots[old];
    		roots[old] = node;
    	}
    	return node;
    	
    }
	
    public int maxHeight(int[][] cuboids) {
    	HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<int[]> arr = new ArrayList<>();
        for(int i=0; i<cuboids.length; i++) {
        	int x = cuboids[i][0];
        	int y = cuboids[i][1];
        	int z = cuboids[i][2];
        	Set<Integer> set = new HashSet<>();
        	set.add(x*1000000+y*1000+z);
        	set.add(x*1000000+z*1000+y);
        	set.add(y*1000000+x*1000+z);
        	set.add(y*1000000+z*1000+x);
        	set.add(z*1000000+x*1000+y);
        	set.add(z*1000000+y*1000+x);
        	for(int num: set) {
        		if(map.containsKey(num))
        			map.put(num, map.get(num)+1);
        		else {
        			arr.add(new int[] {num/1000000, (num/1000)%1000,num%1000});
        			map.put(num, 1);
        		}
        	}
        }
        int[] values = new int[arr.size()];
        for(int i=0; i<arr.size(); i++) {
        	values[i] = arr.get(i)[2];
        	values[i]*= map.get(arr.get(i)[0]*1000000+arr.get(i)[1]*1000+arr.get(i)[2]);
        }
        ArrayList<Integer>[] edges = new ArrayList[arr.size()];
        Set<Integer> set = new HashSet<>();
        for(int i=0; i<arr.size(); i++)
        	edges[i] = new ArrayList<>();
        for(int i=0; i<arr.size(); i++) {
        	for(int j=0; j<arr.size(); j++) {
        		if(i==j)continue;
        		if(arr.get(i)[0]>=arr.get(j)[0]&&arr.get(i)[1]>=arr.get(j)[1]&&arr.get(i)[2]>=arr.get(j)[2]) {
        			edges[i].add(j);
        			set.add(j);
        		}
        	}
        }
        LinkedList<Integer> list = new LinkedList<>();
        for(int i=0; i<arr.size(); i++) {
        	if(!set.contains(i))
        		list.add(i);
        }
        int[] dist = new int[arr.size()];
        for(int i=0; i<arr.size(); i++)
        	dist[i] = values[i];
        while(!list.isEmpty()) {
        	int curr = list.removeFirst();
        	ArrayList<Integer> paths = edges[curr];
        	int size = paths.size();
        	for(int i=0; i<size; i++) {
        		int tar = paths.get(i);
        		if(dist[curr] + values[tar]>dist[tar]) {
        			dist[tar] = dist[curr] + values[tar];
        			list.add(tar);
        		}
        	}
        }
        int ans = 0;
        for(int i=0; i<arr.size(); i++)
        	ans = Math.max(dist[i], ans);
        return ans;
    }
	
    static List<List<Integer>> list;
    static int[] arr;
    static int tar;
    static int N;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        list = new ArrayList<>();
        arr = candidates.clone();
        tar = target;
        N = arr.length;
        recursion(0,new LinkedList<>(),0);
        return list;
    }
    static void recursion(int pos, LinkedList<Integer> curr, int sum) {
    	if(sum>tar)
    		return;
    	if(sum==tar) {
    		list.add((List<Integer>) curr.clone());
    		return;
    	}
    	for(int i=pos; i<N; i++) {
    		curr.add(arr[i]);
    		recursion(i,curr,sum+arr[i]);
    		curr.removeLast();
    	}
    }
    
    
	static int[][] parents;
    public void TreeAncestor(int n, int[] parent) {
    	parents = new int[n][(int)Math.ceil(Math.log10(n)/Math.log10(2))+1];
    	for(int i=0; i<n; i++)
    		parents[i][0] = parent[i];
    	int pos=1;
    	for(int i=2; i<n; i*=2) {
    		for(int j=0; j<n; j++) {
    			if(parents[j][pos-1]==-1) {
    				parents[j][pos] = -1;
    				continue;
    			}
    			parents[j][pos] = parents[parents[j][pos-1]][pos-1];
    		}
    		pos++;
    	}
    }
    
    public int getKthAncestor(int node, int k) {
        int mult = (int) Math.pow(2,parents[0].length-1);
        int pos = parents[0].length-1;
        while(k>0) {
        	while(mult>k) {
        		mult/=2;
        		pos--;
        	}
        	k-=mult;
        	node = parents[node][pos];
        	if(node==-1)
        		break;
        }
        return node;
    }
    public int splitArray(int[] nums, int m) {
        int N = nums.length;
        int[][] dp = new int[N][m];
        int[] summary = new int[N+1];
        for(int i=1; i<=N; i++) {
        	summary[i] = summary[i-1] + nums[i-1];
        	dp[i-1][0] = summary[i];
        }
        for(int i=1; i<N; i++) {
        	for(int j=1; j<Math.min(i+1, m); j++) {
        		int min = Integer.MAX_VALUE;
        		for(int k = i-1; k>=0; k--)
        			min = Math.min(min, Math.max(dp[k][j-1], summary[i+1]-summary[k+1]));
        		dp[i][j] = min;
        	}
        }
        return dp[N-1][m-1];
       
    }
    public int minimumDistance(String word) {
    	int N = word.length();
        int[][] dist = new int[26][26];
        for(int i=0; i<26; i++) {
        	for(int j=0; j<26; j++) {
        		if(i!=j) {
        			int x1 = i/6;
        			int y1 = i%6;
        			int x2 = j/6;
        			int y2 = j%6;
        			dist[i][j] = Math.abs(x1-x2)+Math.abs(y1-y2);
        		}
        	}
        }
        int[][] dp = new int[N][N+1];
        for(int i=1; i<N; i++) {
        	dp[i][0] = dp[i-1][0] + dist[word.charAt(i-1)-'A'][word.charAt(i) -'A'];
        	for(int j=1; j<i+1; j++) {
        		
        		int min = Integer.MAX_VALUE;
        		if(i!=j+1)
        			min = dp[i-1][j] + dist[word.charAt(i-1)-'A'][word.charAt(i) -'A'];
        		min = Math.min(min, dp[i-1][0]);
        		int time =0;
        		for(int k = j; j<i; j++) {
        			time +=dist[word.charAt(k)-'A'][word.charAt(k+1)-'A'];
        		}
        		for(int k=j-1; k>0; k--) {
        			min = Math.min(min, dp[j-1][k]+dist[word.charAt(k-1)-'A'][word.charAt(j)-'A']+time);
        		}
        		dp[i][j] = min;
        	}
        }
        int ans = Integer.MAX_VALUE;
        for(int i=0; i<N+1; i++)
        	ans = Math.min(ans, dp[N-1][i]);
        return ans;
    }
    
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int s1 = nums1.length;
        int s2 = nums2.length;
        if((s1+s2)% 2 ==0) {
        	return (double)((double)findK(nums1, nums2, (s1+s2)/2)+(double)findK(nums1, nums2, ((s1+s2)/2)-1))/2;
        }
        else {
        	return (double)findK(nums1, nums2, (s1+s2)/2);
        }
    }
    public static int findK(int[] nums1, int[] nums2, int k) {
    	int s1 = nums1.length;
    	int s2 = nums2.length;
    	int pos1 =0;
    	int pos2 =0;
    	int curr =k/2;
    	while(pos1+pos2!=k) {
    		if((nums1[pos1] > nums2[pos2]&&pos2 + curr<s2)||pos1 + curr>=s1) {
    			pos2 +=curr;
    		}
    		else {
    			pos1 += curr;
    		}
    		curr/=2;
    		if(curr==0)
    			curr =1;
    	}
    	return Math.max(nums1[pos1], nums2[pos2]);
    }
    public int minInsertions(String s) {
        int N = s.length();
        if(N<2)
            return 0;
        int[][] dp = new int[N][N];
        for(int i=0; i<N-1; i++){
            if(s.charAt(i)!=s.charAt(i+1))
                dp[i][i+1] =1;
            else
                dp[i][i+1] =0;
        }
        for(int len =2; len<N; len++){
            for(int i=0; i+len<N; i++){
                int j = i+len;
                if(s.charAt(i)==s.charAt(j))
                    dp[i][j] = dp[i+1][j-1];
                else
                    dp[i][j] = Math.min(dp[i+1][j-1] +2, Math.min(dp[i+1][j]+1, dp[i][j-1]+1));
            }
        }
        return dp[0][N-1];
    }
	public int rectangleFilling(int[][] data) {
		int N = data.length;
		int[] dp = new int[N];
		for(int i=0 ; i<N; i++) {
			if(dp[i]>0)continue;
			recursion(dp,N,i,data);
		}
		int ans =0;
		for(int i=0; i<N; i++) {
			ans = Math.max(ans, dp[i]);
		}
		return ans;
	}
	public static void recursion(int[] dp, int N, int curr, int[][] data) {
		int max=1;
		for(int i=0; i<N; i++) {
			if(i==curr)continue;
			if(data[i][0]<=data[curr][0] && data[i][1]<=data[curr][1]) {
				if(dp[i]>0)max = Math.max(max, dp[i]+1);
				else {
					recursion(dp,N,i,data);
					max = Math.max(max, dp[i]);
				}
			}
		}
		dp[curr]=max;
	}
    public int minDistance(String word1, String word2) {
    	int N = word1.length()+1;
    	int M = word2.length()+1;
        if(N==1&M==1)
            return 0;
        if(N==1||M==1)
            return N+M-2;
    	char[] w1 = word1.toCharArray();
    	char[] w2 = word2.toCharArray();
    	int[][] dp = new int[N][M];
    	for(int i=0; i<N; i++) 
    		dp[i][0] = i;
    	for(int i=0; i<M; i++)
    		dp[0][i] = i;
    	for(int i=1; i<N; i++) {
    		for(int j=1; j<M;j++) {
    			if(w1[i-1]==w2[j-1])
    				dp[i][j] = dp[i-1][j-1];
    			else
    				dp[i][j] = 1+ Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1]));
    		}
    	}
    	return dp[N-1][M-1];
    }
    public int longestPalindromeSubseq(String s) {
        int N = s.length();
        char[] arr = s.toCharArray();
        int[][] dp = new int[N][N];
        for(int i=0; i<N; i++)
        	dp[i][i] = 1;
        for(int i=0; i<N-1; i++) {
        	if(arr[i]==arr[i+1])
        		dp[i][i+1] = 2;
        	else
        		dp[i][i+1] =1;
        }
        for(int len =2; len<N; len++) {
        	for(int i=0; i+len<N; i++) {
        		int j = i+len;
        		if(arr[i]==arr[j])
        			dp[i][j] = dp[i+1][j-1]+2;
        		else 
        			dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j]);
        	}
        }
        return dp[0][N-1];
    }
    public int maxCoins(int[] nums) {
        int N = nums.length;
        int[] arr = new int[N+2];
        for(int i=0; i<N; i++){
            arr[i+1]= nums[i];
        }
        arr[0]=1;
        arr[N+1]=1;
        int[][] dp = new int[N][N];
        for(int i=0; i<N; i++){
            for(int j=0; j+i<N; j++){
                int x =j;
                int y = i+j;
                if(x==y){
                    dp[x][y] = arr[x+1]*arr[x]*arr[x+2];
                    continue;
                }
                for(int k=x; k<y; k++){
                    dp[x][y] = Math.max(dp[x][y], dp[x][k] + dp[k+1][y]-arr[k+1]*arr[k+2]*arr[k+3]+arr[k+2]*arr[k+3]*arr[x]);
                    dp[x][y] = Math.max(dp[x][y], dp[k+1][y] + dp[x][k]-arr[k]*arr[k+1]*arr[k+2]+arr[k]*arr[k+1]*arr[y+2]);
                }
            }
        }
        return dp[0][N-1];
    }
    public int maxScoreWords(String[] words, char[] letters, int[] score) {
        int[][] list = new int[26][2];
        for(int i=0; i<letters.length; i++) {
        	list[letters[i]-'a'][1]++ ;
        }
        for(int i=0; i<score.length; i++) {
        	list[i][0]=score[i];
        }
        int a =recursion(words, list, 0, false);
        int b = recursion (words, list, 0, true);
        return Math.max(a, b);
    }
    
    public static int recursion(String[] words, int[][] list, int curr,boolean b) {
    	int s1=0;
    	int s2 =0;
    	int[][] list2 = new int[list.length][list[0].length];
    	for(int i=0; i<26; i++) {
    		for(int j=0; j<2; j++) {
    			list2[i][j]=list[i][j];
    		}
    	}
    	if(b==false) {
    		if(curr!=words.length-1) {
    			s1 =recursion(words, list, curr+1, true);
    			s2 = recursion (words, list2, curr+1, false);
    		}
    		return Math.max(s1, s2);
    	}
    	if(b==true) {
    		char[] cars = words[curr].toCharArray();
    		int add=0;
    		for(int i=0; i<cars.length; i++) {
    			int n = cars[i]-'a';
    			if(list[n][1]==0) {
    				add=-100000000;
    				break;
    			}
    			add += list[n][0];
    			list[n][1]--;
    			list2[n][1]--;
    		}
    		if(curr!=words.length-1) {
    			s1 =recursion(words, list, curr+1, true);
    			s2 = recursion (words, list2, curr+1, false);
    		}
    		return Math.max(s1, s2)+add;
    	}
    	return 0;
    }

    
    public int closedIsland(int[][] grid) {
        boolean[][] visit = new boolean[grid.length][grid[0].length];
        int ans =0;
        LinkedList<int[]> list = new LinkedList<>();
        int[][] direct = new int[][] {{1,0},{0,1},{-1,0},{0,-1}}; 
        for(int i=0; i<grid.length; i++) {
        	for(int j=0; j<grid[0].length; j++) {
        		if(visit[i][j]==true)
        			continue;
        		if(grid[i][j]==1)
        			continue;
        		int[]a = new int[] {i,j};
        		boolean istrue = true;
        		list.add(a);
        		if(i==0||i==grid.length-1||j==0||j==grid[0].length-1) {
					istrue=false;
				}
        		while(!list.isEmpty()) {
        			int[] use = list.removeFirst();
        			visit[use[0]][use[1]] = true;
        			for(int k=0; k<4; k++) {
        				int x = use[0] + direct[k][0];
        				int y = use[1] + direct[k][1];
        				if(x>-1&&x<grid.length&& y > -1 && y <grid[0].length) {
        					if(grid[x][y]==1)
        						continue;
        					if(visit[x][y]==true)
        						continue;
        					visit[x][y] = true;
        					if(x==0||x==grid.length-1||y==0||y==grid[0].length-1) {
        						istrue=false;
        					}
        					int[] temp = new int[] {x,y};
        					list.add(temp);
        				}
        			}
        		}
        		if(istrue==true)
        			ans++;
        	}
        }
        return ans;
    }
    public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {
        int[][] ans = new int[colsum.length][2];
        for(int i=0; i<colsum.length; i++) {
        	if(colsum[i]==0) {
        		ans[i][0] =0;
        		ans[i][1] =0;
        		continue;
        	}
        	if(colsum[i]==2) {
        		ans[i][0] =1;
        		ans[i][1] =1;
        		upper--;
        		lower--;
        		continue;
        	}
        	if(upper>lower) {
        		upper--;
        		ans[i][0]=1;
        		ans[i][1]=0;
        	}
        	else {
        		lower--;
        		ans[i][0]=0;
        		ans[i][1]=1;
        	}
        }
        List<List<Integer>> arr = new ArrayList<>();
        if(lower!=0||upper!=0)
        	return arr;
        for(int i=0; i<2; i++) {
        	ArrayList<Integer> al = new ArrayList<>();
        	for(int j=0; j<colsum.length; j++) {
        		al.add(ans[j][i]);
        	}
        	arr.add(al);
        }
        return arr;
    }
    public int minimumSwap(String s1, String s2) {
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        int cx =0;
        int cy =0;
        for(int i=0; i<c1.length; i++) {
        	if(c1[i] == 'x')cx++;
        	if(c1[i] =='y')cy++;
        	if(c2[i] == 'x')cx++;
        	if(c2[i] =='y')cy++;
        }
        if(cx%2==1 || cy % 2 ==1)return -1;
        int count1 =0;
        for(int i=0; i<c1.length; i++) {
        	if(c1[i] == c2[i])continue;
        	boolean b =false;
        	for(int j=i+1; j<c1.length; j++) {
        		if(c1[i]==c1[j]&& c1[j]!= c2[j]) {
        			char save = c2[i];
        			c2[i] = c1[j];
        			c1[j] = save;
        			count1++;
        			b = true;
        			break;
        		}
        	}
        	if(b==false) {
        		for(int j =i+1; j<c2.length; j++) {
            		if(c1[i]==c2[j]&& c1[j]!= c2[j]) {
            			char save = c2[i];
            			c2[i] = c2[j];
            			c2[j] = save;
            			count1+=2;
            			break;
            		}        			
        		}
        	}
        }
        c1 = s1.toCharArray();
        c2 = s2.toCharArray();
        char[] s = c1.clone();
        c1 = c2.clone();
        c2 = s.clone();
        int count2 =0;
        for(int i=0; i<c1.length; i++) {
        	if(c1[i] == c2[i])continue;
        	boolean b =false;
        	for(int j=i+1; j<c1.length; j++) {
        		if(c1[i]==c1[j]&& c1[j]!= c2[j]) {
        			char save = c2[i];
        			c2[i] = c1[j];
        			c1[j] = save;
        			count2++;
        			b = true;
        			break;
        		}
        	}
        	if(b==false) {
        		for(int j =i+1; j<c2.length; j++) {
            		if(c1[i]==c2[j]&& c1[j]!= c2[j]) {
            			char save = c2[i];
            			c2[i] = c2[j];
            			c2[j] = save;
            			count2+=2;
            			break;
            		}        			
        		}
        	}
        }
        return Math.min(count1, count2);
    }
    public int trap(int[] height) {
        int max1 =-1;
        int max2 = -1;
        int pos1 =-1;
        int pos2 = -1;
        for(int i=0; i<height.length;i++){
            if(height[i]>max1){
                max2 = max1;
                pos2 = pos1;
                max1 = height[i];
                pos1 = i;
                continue;
            }
            if(height[i]>max2){
                max2 = height[i];
                pos2 = i;
            }
        }
        int total =0;
        for(int i=pos1; i<=pos2; i++)
            total += Math.max(Math.min(max1, max2)- height[i],0);
        int max =0;
        for(int i=0; i<pos1; i++){
            max = Math.max(max, height[i]);
            total += (max - height[i]);
        }
        max =0;
        for(int i = height.length-1; i>pos2; i--){
            max = Math.max(max, height[i]);
            total += (max - height[i]);
        }
        return total;
    }
    public int largest1BorderedSquare(int[][] grid) {
        int[][] hor=new int[grid.length][grid[0].length];
        int[][] ver =new int[grid.length][grid[0].length];
        for(int i=0; i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(j==0){
                    hor[i][j]+=grid[i][j];
                    continue;
                }
                hor[i][j]=grid[i][j]+hor[i][j-1];
            }
        }
        for(int i=0; i<grid[0].length; i++){
            for(int j=0; j<grid.length; j++){
                if(j==0){
                    ver[j][i]+=grid[j][i];
                    continue;
                }
                ver[j][i]=grid[j][i]+ver[j-1][i];
            }
        }
        int max=0;
        for(int i=0; i<Math.min(grid.length,grid[0].length); i++){
            for(int j=i; j<grid.length; j++){
                for(int k=i; k<grid[0].length; k++){
                    if(i==j&&k==i){
                        if(hor[j][k]==i+1&&ver[j][k]==i+1&&hor[j-i][k]==i+1&&ver[j][k-i]==i+1)
                            max=Math.max(max,i+1);
                        continue;
                    }
                    if(i==j){
                        if(hor[j][k]-hor[j][k-i-1]==i+1&&ver[j][k]==i+1&&hor[j-i][k]-hor[j-i][k-i-1]==i+1&&ver[j][k-i]==i+1)
                            max=Math.max(max,i+1);
                        continue;                        
                    }
                    if(k==i){
                        if(hor[j][k]==i+1&&ver[j][k]-ver[j-i-1][k]==i+1&&hor[j-i][k]==i+1&&ver[j][k-i]-ver[j-i-1][k-i]==i+1)
                            max=Math.max(max,i+1);
                        continue;                        
                    }
                    if(hor[j][k]-hor[j][k-i-1]==i+1&&ver[j][k]-ver[j-i-1][k]==i+1&&hor[j-i][k]-hor[j-i][k-i-1]==i+1&&ver[j][k-i]-ver[j-i-1][k-i]==i+1)
                        max=Math.max(max,i+1);
                    continue;
                }
            }
        }
        return max;
    }
	public String alienDictionary(String[] dic) {
		Set<Character> set=new HashSet<>();
		Map<Character, Integer> map=new HashMap<>();
		Map<Integer, Character> back=new HashMap<>();
		int a=0;
		for(int i=0; i<dic.length; i++) {
			int s=dic[i].length();
			for(int j=0; j<s; j++) {
				int o=set.size();
				set.add(dic[i].charAt(j));
				if(set.size()!=o) {
					back.put(a,dic[i].charAt(j));
					map.put(dic[i].charAt(j), a++);
				}
			}
		}
		ArrayList<Integer>[] pre=new ArrayList[set.size()];
		ArrayList<Integer>[] post =new ArrayList[set.size()];
		for(int i=0; i<set.size(); i++) {
			pre[i]=new ArrayList<>();
			post[i]=new ArrayList<>();
		}
		wordCompare(pre,post,map,dic,0, dic.length-1, 0);
		char[] ans=new char[set.size()];
		boolean[] visit=new boolean[set.size()];
		LinkedList<Character> list =new LinkedList<>();
		for(int i=0; i<set.size(); i++) {
			if(pre[i].isEmpty()) {
				list.add(back.get(i));
			}
		}
		int c=0;
		while(!list.isEmpty()) {
			char curr=list.removeFirst();
			ans[c++]=curr;
			visit[map.get(curr)]=true;
			ArrayList<Integer> al=post[map.get(curr)];
			int s=al.size();
			for(int i=0; i<s; i++) {
				int par=al.get(i);
				ArrayList<Integer> child=pre[par];
				int s2=child.size();
				boolean b=true;
				for(int j=0; j<s2; j++) {
					if(visit[child.get(j)]==false) {
						b=false;
						break;
					}
				}
				if(b==true)
					list.add(back.get(par));
			}
		}
		if(c!=set.size())
			return "";
		else
			return new String(ans);
	}
	public void wordCompare(ArrayList<Integer>[] pre, ArrayList<Integer>[] post, Map<Character, Integer> map, String[] dic, int start, int end, int depth) {
		for(int i=start; i<end; i++) {
			if(dic[i].charAt(depth)==dic[i+1].charAt(depth)) {
				if(depth<dic[i].length()-1&&depth<dic[i+1].length()-1) {
					wordCompare(pre,post,map,dic,i,i+1,depth+1);
				}
			}
			else {
				pre[map.get(dic[i+1].charAt(depth))].add(map.get(dic[i].charAt(depth)));
				post[map.get(dic[i].charAt(depth))].add(map.get(dic[i+1].charAt(depth)));
			}
		}
	}
    public int lastStoneWeightII(int[] stones) {
        ArrayList<Integer> list=new ArrayList<>();
        for(int i=0; i<stones.length; i++)
            list.add(stones[i]);
        while(list.size()>1){
            int max1=0;
            int max2=0;
            int pos1=-1;
            int pos2=-1;
            for(int i=0; i<list.size(); i++){
                if(max1<list.get(i)){
                    pos1=i;
                    max1=list.get(i);
                }
            }
            for(int i=0; i<list.size(); i++){
                if(max2<list.get(i)&&i!=pos1){
                    max2=list.get(i);
                    pos2=i;
                }
            }
            list.remove(pos1);
            if(pos2>pos1)
                list.remove(pos2-1);
            else
                list.remove(pos2);
            if(max1!=max2)
            	list.add(max1-max2);
        }
        if(list.size()==1)
            return list.get(0);
        else
            return 0;
    }
    public void useless(int s, int e) {
    	int count=0;
    	for(int i=s; i<e+1; i++) {
    		double sum=(s*s*11*(s-1))/2;
    		if(sum>(int)sum)
    			continue;
    		sum+=100;
    		int curr=0;
    		while(sum>=1) {
    			int a=(int) (sum%10);
    			curr+=(a)*(a);
    			sum/=10;
    		}
    		if(curr<=512)
    			count++;
    	}
    	System.out.println(count);
    }
	public int minStickers(String[] stickers, String target) {
		Map<Character, Integer> map=new HashMap<>();
		int pos=0;
		for(int i=0; i<target.length(); i++) {
			if(map.get(target.charAt(i))==null) {
				map.put(target.charAt(i), pos++);
			}
		}
		int[] tar=new int[pos];
		for(int i=0; i<target.length(); i++) {
			tar[map.get(target.charAt(i))]++;
		}
		int[][] fake=new int[stickers.length][pos];
		for(int i=0; i<stickers.length; i++) {
			for(int j=0; j<stickers[i].length(); j++) {
				if(map.get(stickers[i].charAt(j))==null)
					continue;
				else
					fake[i][map.get(stickers[i].charAt(j))]++;
			}
		}
		boolean[] gone=new boolean[stickers.length];
		for(int i=0; i<stickers.length; i++) {
			for(int j=0; j<stickers.length; j++) {
				if(i==j)
					continue;
				boolean isSmall= true;
				for(int k=0; k<pos; k++) {
					if(fake[i][k]>fake[j][k]) {
						isSmall=false;
						break;
					}
				}
				boolean isSame =true;
				for(int k=0; k<pos; k++) {
					if(fake[i][k]!=fake[j][k]) {
						isSame=false;
						break;
					}
				}
				if(isSmall==true&&isSame==false) 
					gone[i]=true;
					
			}
		}
		int size=0;
		for(int i=0; i<gone.length; i++) {
			if(gone[i]==false)
				size++;
		}
		int[][] items=new int[size][pos];
		int curr=0;
		for(int i=0; i<stickers.length; i++) {
			if(gone[i]==false) {
				items[curr]=fake[i].clone();
				curr++;
			}
		}
		LinkedList<int[]> list=new LinkedList<>();
		int[] a=new int[pos];
		list.add(a);
		for(int i=0; i<15; i++) {
			int n=list.size();
			for(int j=0; j<n; j++) {
				int[] arr=list.removeFirst();
				ArrayList<Integer> need=new ArrayList<>();
				for(int k=0; k<arr.length; k++) {
					if(tar[k]>arr[k])
						need.add(k);
				}
				for(int k=0; k<size; k++) {
					boolean c=false;
					for(int l=0; l<need.size(); l++) {
						if(items[k][need.get(l)]>0) {
							c=true;
							break;
						}
					}
					if(c==false)
						continue;
					int[] temp=arr.clone();
					boolean b=true;
					for(int l=0; l<pos; l++) {
						temp[l]+=items[k][l];
						if(temp[l]<tar[l])
							b=false;
					}
					if(b==true)
						return i+1;
					list.add(temp);
				}
			}
		}
		return -1;
	}
    public String longestDupSubstring(String S) {
        int first=0;
        int last=S.length();
        String ans="";
        Map<Long,ArrayList<Integer>> set=new HashMap<>();
        while(first<=last){
            int mid= first + (last-first)/2;
            
            //test only
            long sum=0;
            long times=1;
            for(int i=0; i<mid; i++) {
            	sum=sum*29+(S.charAt(i)-'a');
            	if(i!=mid-1) {
            		times= times*29;
            		times%=1000000007;
            	}
            	sum%=1000000007;
            }
            ArrayList<Integer> z=new ArrayList<>();
            z.add(0);
            z.add(mid);
            set.put(sum, z);
            boolean b=false;
            for(int i=0; i<S.length()-mid; i++) {
            	long sub=(times*(S.charAt(i)-'a'))%1000000007;
            	sum-=sub;
            	sum*=29;
            	sum+=(S.charAt(i+mid)-'a');
            	sum%=1000000007;
            	if(sum<0) {
            		sum+=1000000007;
            		System.out.println("error");
            	}
            	if(set.get(sum)!=null) {
            		String s1=S.substring(i+1, i+mid+1);
            		ArrayList<Integer> al =set.get(sum);
            		for(int j=0; j<al.size(); j+=2) {
            			String s2=S.substring(al.get(j), al.get(j+1));
            			if(s1.equals(s2)) {
            				ans=s1;
            				b=true;
            				break;
            			}
            		}
            		if(b==true)
            			break;
            		else {
            			al.add(i+1);
            			al.add(i+mid+1);
            			set.put(sum, al);
            		}
            	}
            	else {
            		ArrayList<Integer> al=new ArrayList<>();
            		al.add(i+1);
            		al.add(i+mid+1);
            		set.put(sum, al);
            	}
            	
            }
            if(b==true) 
            	first=mid+1;
            else
            	last=mid-1;
            set.clear();
        }
        System.out.println(ans.length()+"; last=" + last);
        System.out.println(S.length());
        return ans;
    }
    public String shortestCommonSupersequence(String str1, String str2) {
        int[][] dp=new int[str1.length()+1][str2.length()+1];
        for(int i=1; i<str1.length()+1;i++) {
        	for(int j=1; j<str2.length()+1; j++) {
        		if(str1.charAt(i-1)==str2.charAt(j-1)) 
        			dp[i][j]=Math.max(Math.max(dp[i][j-1], dp[i-1][j-1]+1),dp[i-1][j]);
        		else 
        			dp[i][j]=Math.max(Math.max(dp[i][j-1], dp[i-1][j-1]),dp[i-1][j]);
        	}
        }
       int[] t=new int[] {str1.length(),str2.length()};
       LinkedList<int[]> list=new LinkedList<>();
       list.add(t);
       char[] ans=new char[str1.length()+str2.length()-dp[str1.length()][str2.length()]];
       int c=str1.length()+str2.length()-dp[str1.length()][str2.length()]-1;
       while(!list.isEmpty()) {
    	   int[] arr=list.removeFirst();
    	   if(arr[0]==0) {
    		   for(int i=arr[1]; i>0; i--) {
    			   ans[c--]=str2.charAt(i-1);
    		   }
    		   break;
    	   }
    	   if(arr[1]==0) {
    		   for(int i=arr[0]; i>0; i--) {
    			   ans[c--]=str1.charAt(i-1);
    		   }
    		   break;
    	   }
    	   if(dp[arr[0]][arr[1]]==dp[arr[0]][arr[1]-1]) {
    		   int[] temp=new int[] {arr[0],arr[1]-1};
    		   list.add(temp);
    		   ans[c--]=str2.charAt(arr[1]-1);
    		   continue;
    	   }
    	   if(dp[arr[0]][arr[1]]==dp[arr[0]-1][arr[1]]) {
    		   int[] temp=new int[] {arr[0]-1,arr[1]};
    		   list.add(temp);
    		   ans[c--]=str1.charAt(arr[0]-1);
    		   continue;
    	   }
    	   else {
    		   int[] temp=new int[] {arr[0]-1,arr[1]-1};
    		   list.add(temp);
    		   ans[c--]=str1.charAt(arr[0]-1);
    		   if(str1.charAt(arr[0]-1)!=str2.charAt(arr[1]-1))
    			   ans[c--]=str2.charAt(arr[1]-1);
    		   continue;
    	   }
       }
       String s=new String(ans);
       return s;
    }
    public boolean isMatch(String s, String p) {
        LinkedList<Character> list=new LinkedList<>();
        if(p.length()>0)
            list.add(p.charAt(0));
        for(int i=1; i<p.length(); i++){
            if(p.charAt(i)=='*'&&p.charAt(i-1)!='*'){
                list.add(p.charAt(i));
                continue;
            }
            if(p.charAt(i)!='*')
                list.add(p.charAt(i));
        }
        int z=list.size();
        char[] c=new char[z];
        for(int i=0; i<z; i++)
            c[i]=list.removeFirst();
        String q=new String(c);
        return isMatch2(s,q);
    }
    public boolean isMatch2(String s, String p) {
        if(s.length()==0&&p.length()==0)
    		return true;
        if(p.length()==1&&p.charAt(0)=='*')
    		return true;
        if(p.length()==0||s.length()==0)
            return false;
        if(p.charAt(0)=='*') {
        	for(int i=0; i<s.length(); i++) {
        		if(isMatch2(s.substring(i),p.substring(1))==true)
        			return true;
        	}
        	return false;
        }
        else {
        	for(int i=0 ; i<Math.min(s.length(), p.length());i++){
        		if(p.charAt(i)==s.charAt(i)||p.charAt(i)=='?') {
        			continue;
        		}
        		if(p.charAt(i)=='*') {
        			return isMatch2(s.substring(i),p.substring(i));
        		}
        		else
        			return false;
        	}
        	if(s.length()==p.length())
        		return true;
        	else {
        		int need=Math.max(s.length(), p.length())-Math.min(s.length(), p.length());
        		for(int i=s.length(); i<p.length(); i++) {
        			if(p.charAt(i)=='*')
        				need--;
        		}
        		if(need==0)
        			return true;
        		else
        			return false;
        	}
        }
    }
	public int[] findRedundantConnection2(int[][] edges) {
        int[] root = new int[edges.length+1];
        for(int i=1;i<root.length;i++)
        	root[i]=i;
        
        for(int[] e : edges){
            int r0 = findRoot(root, e[0]);
            int r1 = findRoot(root, e[1]);
            if(r0==r1)
                return e;
            root[r1]=r0;
        }
        return null;
    }
    
    int findRoot(int[] connected, int n){
        if(connected[n]==n) return n;
        return findRoot(connected,connected[n]);
    }
    public int[] findRedundantConnection(int[][] edges) {
    	int[] arr=new int[edges.length];
    	for(int i=0; i<edges.length; i++) {
    		arr[i]=i+1;
    	}
    	int use=edges[0][0];
    	for(int i=0; i<edges.length; i++) {
    		int a=edges[i][0];
    		int b=edges[i][1];
    		int r1=arr[a-1];
    		int r2=arr[b-1];
    		if(r1==r2) {
    			int[] temp=new int[] {a,b} ;
    			return temp;
    		}
    		if(arr[a-1]==use) {
    			arr[b-1]=arr[a-1];
    			continue;
    		}
    		if(arr[b-1]==use) {
    			arr[a-1]=arr[b-1];
    			continue;
    		}
    		arr[b-1]=arr[a-1];
    	}
    	return new int[] {94375639};
    }

    public int minMutation(String start, String end, String[] bank) {
        if(bank.length==0){
            if(start.equals(end)==true)
                return 0;
            else
                return -1;
        }
    	HashMap<Character, Integer> map=new HashMap<>();
    	map.put('A', 0);
    	map.put('C', 1);
    	map.put('G', 2);
    	map.put('T', 3);
    	int[] st=new int[start.length()];
    	for(int i=0; i<start.length(); i++) {
    		st[i]=map.get(start.charAt(i));
    	}
    	int[] ed=new int[end.length()];
    	for(int i=0; i<end.length(); i++) {
    		ed[i]=map.get(end.charAt(i));
    	}
    	int[][] bk=new int[bank.length][bank[0].length()];
    	for(int i=0; i<bank.length; i++) {
    		String str=bank[i];
    		for(int j=0; j<str.length();j++) {
    			bk[i][j]=map.get(str.charAt(j));
    		}
    	}
    	int steps=0;
    	LinkedList<int[]>list=new LinkedList<>();
    	list.add(st);
    	while(!list.isEmpty()) {
    		int n=list.size();
    		for(int i=0; i<n; i++) {
    			boolean there=false;
    			int[] use=list.removeFirst();
    			for(int j=0; j<ed.length; j++) {
    				if(use[j]!=ed[j]) {
    					there=true;
    					break;
    				}
    			}
    			if(there==false)
    				return steps;
    			for(int j=0; j<bk.length;j++) {
    				int dif=0;
    				if(bk[j][0]==-1)
    					continue;
    				for(int k=0; k<bk[j].length; k++) {
    					if(bk[j][k]!=use[k]) {
    						dif++;
    						if(dif==2)
    							break;
    					}
    				}
    				if(dif==1) {
    					int[] t=bk[j].clone();
    					list.add(t);
    					bk[j][0]=-1;
    				}
    			}
    		}
    		steps++;
    	} 
        return -1;
    }
    public int scoreOfParentheses(String S) {
    	Stack<Integer> stack=new Stack<>();
    	int[] arr=new int[S.length()];
    	for(int i=0; i<S.length(); i++) {
    		if(S.charAt(i)=='(')
    			stack.push(i);
    		else {
    			int pos=stack.pop();
    			boolean b=false;
    			for(int j=pos; j<i; j++) {
    				if(arr[j]>0) {
    					arr[j]*=2;
    					b=true;
    				}
    			}
    			if(b==false) {
    				arr[pos]=1;
    			}
    		}
    	}
    	int ans=0;
    	for(int i=0; i<S.length(); i++) {
    		ans+=arr[i];
    	}
    	return ans;
        
    }
    public int totalFruit(int[] tree) {
        HashMap<Integer,Integer> map=new HashMap<>();
        int len=0;
        int i=0;
        int j=0;
        while(j<tree.length) {
        	if(map.size()>2) {
        		if(map.get(tree[j])==null)
        			map.put(tree[j], 1);
        		else {
        			int a=map.get(tree[j]);
        			a++;
        			map.put(tree[j], a);
        		}
        		if(map.get(tree[i])==1)
        			map.remove(tree[i]);
        		else {
        			int a=map.get(tree[i]);
        			a--;
        			map.put(tree[i], a);
        		}
        		if(map.size()<3) {
        			len=j-i+1;
        			j++;
        			continue;
        		}
        		i++;
        		j++;
        	}
        	else {
        		if(map.get(tree[j])==null) {
        			map.put(tree[j], 1);
        		}
        		else {
        			int a=map.get(tree[j]);
        			a++;
        			map.put(tree[j], a);
        		}
        		if(map.size()<3) {
        			len=j-i;
        			j++;
        			continue;
        		}
        		i++;
        		if(map.get(tree[i])==1)
        			map.remove(tree[i]);
        		else {
        			int a=map.get(tree[i]);
        			a--;
        			map.put(tree[i], a);
        		}
        		j++;
        	}
        }
		return len;
    }
    boolean allZeros(int[] m){
        for(int k=0;k<26;k++){
            if(m[k]!=0) return false;
        }
        return true;
    }
    
    public boolean checkInclusion(String s1, String s2) {
        int len = s1.length();
        int[] arr1=new int[26];
        for(int i=0;i<len; i++){
            char c=s1.charAt(i);
            arr1[c-'a']--;
            c=s2.charAt(i);
            arr1[c-'a']++;
        }
        if(allZeros(arr1)) return true;
        int i=0; 
        int j=len;
        while(j<s2.length()){
            arr1[s2.charAt(j++)-'a']++;
            arr1[s2.charAt(i++)-'a']--;
            if(allZeros(arr1))
                return true;
        }
        return false;
    }
    public int wiggleMax(int[] nums) {
        if (nums.length <= 2)
            return nums.length;
        int[] pos=new int[nums.length];
        int[] neg=new int[nums.length];
        for(int i=1; i<nums.length ;i++){
            for(int j=0; j<i; j++){
              if (nums[i]>nums[j]) {
                    pos[i]=Math.max(pos[i],neg[j]+1);
                }
                if (nums[i]<nums[j]) {
                    neg[i]=Math.max(pos[j]+1,neg[i]);
                }
            }
        }
        int ans=Math.max(pos[nums.length-1], neg[nums.length-1]);
        ans++;
        return ans;
    }
    */
}
